[id="proc_writing-a-meta-yaml-file-and-adding-it-to-a-plug-in-registry_{context}"]
= Writing a meta.yaml file and adding it to a plug-in registry

The plug-in meta information is required to publish a VS Code extension in an Eclipse Che plug-in registry. This meta information is provided as a `meta.yaml` file. This section describes how to create a `meta.yaml` file for an extension.

.Procedure

. Create a `meta.yaml` file in the following plug-in registry directory: `__<apiVersion>__/plugins/__<publisher>__/__<plug-inName>__/__<plug-inVersion>__/`.
+

. Edit the `meta.yaml` file and provide the necessary information. The configuration file must adhere to the following structure:
+
[source,yaml]
----
apiVersion: v2                                                   <1>
publisher: myorg                                                 <2>
name: my-vscode-ext                                              <3>
version: 1.7.2                                                   <4>
type: value                                                      <5>
displayName:                                                     <6>
title:                                                           <7>
description:                                                     <8>
icon: https://www.eclipse.org/che/images/logo-eclipseche.svg     <9>
repository:                                                     <10>
category:                                                       <11>
firstPublicationDate:                                           <12>
latestUpdateDate:                                               <13>
deprecate:                                                      <14>
    autoMigrate:                                                <15>
    migrateTo:                                                  <16>
spec:
  endpoints:                                                    <17>
    - name:                                                     <18>
      public:                                                   <19>
      targetPort:                                               <20>
      attributes:                                               <21>
        protocol:                                               <22>
        secure:                                                 <23>
        discoverable:                                           <24>
        cookiesAuthEnabled:                                     <25>
        type:                                                   <26>
        path:                                                   <27>
  containers:                                                   <28>
    - image:                                                    <29>
      name:                                                     <30>
      memoryLimit:                                              <31>
      env:                                                      <32>
        - name:                                                 <33>
          value:                                                <34>
      command:                                                  <35>
        - /bin/sh
      args:                                                     <36>
        - -c
        - ./entrypoint.sh
      volumes:                                                  <37>
        - mountPath:                                            <38>
          name:                                                 <39>
          ephemeral:                                            <40>
      ports:                                                    <41>
        - exposedPort:                                          <42>
      commands:                                                 <43>
        - name:                                                 <44>
          workingDir:                                           <45>
          command:                                              <46>
            - rm
            - -rf
            - /cache/.m2/repository
      mountSources:                                             <47>
    initContainers:                                             <48>
    - image:                                                    <29>
      name:                                                     <30>
      memorylimit:                                              <31>
      env:                                                      <32>
        - name:                                                 <33>
          value:                                                <34>
      command:                                                  <35>
        - /bin/sh
      args:                                                     <36>
        - -c
        - ./entrypoint.sh
      volumes:                                                  <37>
        - mountPath:                                            <38>
          name:                                                 <39>
          ephemeral:                                            <40>
      ports:                                                    <41>
        - exposedPort:                                          <42>
      commands:                                                 <43>
        - name:                                                 <44>
          workingDir:                                           <45>
          command:                                              <46>
            - rm
            - -rf
            - /cache/.m2/repository
      mountSources:                                             <47>
  workspaceEnv:                                                 <49>
    - name:                                                     <33>
      value:                                                    <34>
  extensions:                                                   <50>
    - https://github.com/redhat-developer/vscode-yaml/releases/download/0.4.0/redhat.vscode-yaml-0.4.0.vsix
    - vscode:extension/SonarSource.sonarlint-vscode
----
<1> Version of the file structure.
<2> Name of the plug-in publisher. Must be the same as the publisher in the path.
<3> Plug-in name. Must be the same as in path.
<4> The Che plug-in version. Must be the same as in path.
<5> Che plug-in type. For VS Code extensions, it must be `VS Code extension`.
<6> A short name of the plug-in.
<7> Plug-in title.
<8> A brief explanation of the plug-in and what it does.
<9> The link to the plug-in logo.
<10> Optional. The link to the source-code repository of the plug-in.
<11> Defines the category that this plug-in belongs to. Should be one of the following: `Editor`, `Debugger`, `Formatter`, `Language`, `Linter`, `Snippet`, `Theme`, or `Other`.
<12> Optional. The first publication date.
<13> Optional. The last update date. Useful to track meta.yaml history.
<14> Optional. Section for deprecating plug-ins in favor of others.
<15> Boolean. Auto migrate plug-in to the latest version.
<16> Migrate to concreate plug-in version.
<17> Optional. Some plug-ins provide addional endpoint(s) for service(s). This property defines the services endpoints.
<18> Endpoint name.
<19> Boolean. If true, endpoint is exposed publicly.
<20> Exposed port for endpoint.
<21> Optional endpoint attributes.
<22> Protocol used for communicating over endpoint, e.g. 'ws', 'http', 'https'.
<23> Use secure version of protocol above; convert 'ws' -> 'wss', 'http' -> 'https'.
<24> Boolean. If false, no k8s service is created for this endpoint.
<25> Boolean. If true, endpoint is exposed through JWTProxy.
<26> Endpoint type. There are some special endpoint types for Eclipse Che.
For example if you want to apply own plug-in editor,
you should mark endpoint with type 'ide' and Eclipse Che will open your endpoint and show editor,
when workspace loader compete work on workspace start.
<27> Path to some sub-part service api.
For example you have some rest api http://localhost:3550/ inside container.
But you want to expose some part of the api http://localhost:3130/articles, than you can define path like `/articles`.
<28> Plug-in containers. Notice: "Theia plug-in" and 'VS Code extension' can have only one container.
<29> The Docker image from which sidecar container will be started. Example: `eclipse/che-theia-endpoint-runtime-binary`.
<30> Image name.
<31> Default RAM size for sidecar container. Example: "256Mi". This value might be overridden by the user in the component configuration.
<32> Optional. List of env variables in plug-in container.
<33> Env variable name.
<34> Env variable value.
<35> Optional. Definition of root process command inside container. Using this option you can override Dockerfile#Entrypoint.
<36> Optional. List arguments for root process command inside container. Using this option you can override Dockerfile#CMD.
<37> Optional. Volumes required by plug-in.
<38> Volume path in the container file system.
<39> Volume name.
<40> Boolean. If true, volume will be ephemeral, so its content will be erased after Eclipse Che workspace restart.
If false, volume content will be persisted between Eclipse Che workspace restart.
Default value is false.
<41> Optional. Ports exposed by plug-in (on the container) for external services.
<42> Exposed port value.
<43> Optional. Development commands available to plug-in container.
<44> Command name.
<45> Working directory for command.
<46> List of commands + arguments.
<47> Optional. Boolean. All user's projects inside Eclipse Che workspace stored in the volume `/projects`. Property should be true if you want to share this volume with you plug-in container. Default value is false.
<48> Optional. List of init containers. Could be useful when you need to manipulate with some data in your containers at runtime.
<49> Optional. List of common env vars for all workspace containers.
<50> List of extensions: consist of plug-ins with type `VS Code extension` and `Theia plug-in` that should be run in this sidecar container.

## Using initContainers for plug-ins

Inside Eclipse Che workspace you can use init containers. Init containers always start before containers and init containers always run to completion.
Each init container must complete successfully before the next one starts.
For remote plug-in init containers could be useful to change some configuration files or include some binaries to the container volume. Use plug-in meta.yaml field `initContainers` to define list init containers.

## Remote plug-in endpoint

Eclipse Che has remote plug-in endpoint service to start VS Code Extensions and Che theia plug-ins in the separated containers. Eclipse Che inject remote plug-in endpoint binaries to each remote plug-in container. This service start your remote extensions and plug-ins defined in the plug-in meta.yaml#extensions file and connect them to the che-theia editor container.

Main goal of remote plug-in endpoint - creation plugin api proxy between your remote plug-in container and che-theia editor container. Also remote plug-in endpoint is interceptor for some plug-in api parts to launch them inside remote sidecar container, instead of editor container. For example terminal api, debug api and so on.

Remote plug-in endpoint executable command stored in the env variable of the remote plug-in container:

`PLUGIN_REMOTE_ENDPOINT_EXECUTABLE`

Execution remote plugin endpoint using shell:

`${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}`

## Prepare plug-in image and meta.yaml to use remote plug-in endpoint.

> Notice: Since Eclipse Che 7.3.1

Eclipse Che provides two ways to start remote plug-in endpoint with your sidecar image:

 - plug-in writer defines launch remote plug-in endpoint using Dockerfile. Requires image patching and rebuild.
 - plug-in writer defines launch remote plug-in endpoint in the plug-in meta.yaml. This way plugin writer should use if he doesn't want to patch some original image to start remote plug-in endpoint.

## Define launch remote plug-in endpoint using Dockerfile.

To start remote plug-in endpoint use env variable `PLUGIN_REMOTE_ENDPOINT_EXECUTABLE` in the Dockerfile.

1) You can start remote plug-in endpoint using Dockerfile#CMD:

```dockerfile
FROM fedora:30

RUN dnf update -y && dnf install -y nodejs htop && node -v

RUN mkdir /home/user

ENV HOME=/home/user

RUN mkdir /projects \
    && chmod -R g+rwX /projects \
    && chmod -R g+rwX "${HOME}"

CMD ${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}
```

2) You can start remote plug-in endpoint using Dockerfile#ENTRYPOINT:

```dockerfile
FROM fedora:30

RUN dnf update -y && dnf install -y nodejs htop && node -v

RUN mkdir /home/user

ENV HOME=/home/user

RUN mkdir /projects \
    && chmod -R g+rwX /projects \
    && chmod -R g+rwX "${HOME}"

ENTRYPOINT ${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}
```

3) There are some images which uses wrapper script pattern. Main pattern idea: start script defined in the Dockerfile#Entrypoint to fix some permissions inside container and then script executes main process defined in the Dockerfile#CMD. Eclipse Che could use such images with wrapper script to provide some permission fixes on the different infrastructures with advanced security, for example Openshift.

Example of the wrapper script:

```shell
#!/bin/sh

set -e

export USER_ID=$(id -u)
export GROUP_ID=$(id -g)

if ! whoami >/dev/null 2>&1; then
    echo "${USER_NAME:-user}:x:${USER_ID}:0:${USER_NAME:-user} user:${HOME}:/bin/sh" >> /etc/passwd
fi

# Grant access to projects volume in case of non root user with sudo rights
if [ "${USER_ID}" -ne 0 ] && command -v sudo >/dev/null 2>&1 && sudo -n true > /dev/null 2>&1; then
    sudo chown "${USER_ID}:${GROUP_ID}" /projects
fi

exec "$@"
```

Dockerfile:

```dockerfile
FROM alpine:3.10.2

ENV HOME=/home/theia

RUN mkdir /projects ${HOME} && \
    # Change permissions to let any arbitrary user
    for f in "${HOME}" "/etc/passwd" "/projects"; do \
      echo "Changing permissions on ${f}" && chgrp -R 0 ${f} && \
      chmod -R g+rwX ${f}; \
    done

ADD entrypoint.sh /entrypoint.sh

ENTRYPOINT [ "/entrypoint.sh" ]
CMD ${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}
```

How it works? Container on start launch `/entrypoint.sh` script defined in the Dockerfile#ENTRYPOINT, this script fix permissions and execute command using `exec $@`. Like argument for our ENTRYPOINT will be CMD, that’s why command `exec $@` will call `${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}` and remote plug-in endpoint starts in the container after permission fix.

## Define launch remote plug-in endpoint in the plug-in meta.yaml

There are a lot of images which were already created and you want to reuse them to start remote plug-in endpoint without modification. In this case you can try to use image like is, but you need to change plug-in meta.yaml definition to start remote plug-in endpoint. To achieve this purpose plug-in meta.yaml definition in the container section has two properties: `command` and `args`:

- `command` - Eclipse Che uses to override Dockerfile#ENTRYPOINT.
- `args`  - Eclipse Che uses to override Dockerfile#CMD.

1) So if you want to override both Dockerfile#ENTRYPOINT, Dockerfile#CMD and start remote plug-in endpoint, you can do something like that:

```yaml
---
apiVersion: v2
category: Language
description: "Typescript language features"
displayName: Typescript
firstPublicationDate: "2019-10-28"
icon: "https://www.eclipse.org/che/images/logo-eclipseche.svg"
name: typescript
publisher: che-incubator
repository: "https://github.com/Microsoft/vscode"
title: "Typescript language features"
type: "VS Code extension"
version: remote-bin-with-override-entrypoint
spec:
  containers:
    - image: "example/fedora-for-ts-remote-plugin-without-endpoint:latest"
      memoryLimit: 512Mi
      name: vscode-typescript
      command:
        - sh
        - -c
      args:
        - ${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}
  extensions:
    - "https://github.com/che-incubator/ms-code.typescript/releases/download/v1.35.1/che-typescript-language-1.35.1.vsix"
```


2) If you have an image with wrapper script pattern, than you are interested in saving call entypoint.sh. That’s why you should override `args` instead of `command` in the plug-in metal.yaml section:

```yaml
---
apiVersion: v2
category: Language
description: "Typescript language features"
displayName: Typescript
firstPublicationDate: "2019-10-28"
icon: "https://www.eclipse.org/che/images/logo-eclipseche.svg"
name: typescript
publisher: che-incubator
repository: "https://github.com/Microsoft/vscode"
title: "Typescript language features"
type: "VS Code extension"
version: remote-bin-with-override-entrypoint
spec:
  containers:
    - image: "example/fedora-for-ts-remote-plugin-without-endpoint:latest"
      memoryLimit: 512Mi
      name: vscode-typescript
      args:
        - sh
        - -c
        - ${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}
  extensions:
    - "https://github.com/che-incubator/ms-code.typescript/releases/download/v1.35.1/che-typescript-language-1.35.1.vsix"
```

In this case Eclipse Che will call entrypoint.sh defined in the Dockerfile#Entrypoint, and entrypoint.sh like wrapper script will call `[ ‘sh’, ‘-c”, ‘ ${PLUGIN_REMOTE_ENDPOINT_EXECUTABLE}’ ]` using `exec “$@”`.

3) There are another remote plug-in image cases. For example for remote plug-in you want to execute some service on start container and also you need to start remote plug-in endpoint. In this case you still can use meta.yaml `command` and `args`. You can start your service, detach process and start remote plugin endpoint and they will work parallel together.

## Plug-in endpoints

> Notice: Since Eclipse Che 7.3.1

This feature provide ability to define some services and use them with your VS Code extesion or Che Theia plug-in. To expose and define service(s) you can use plug-in meta.yaml property `endpoints`. This property is array endpoint definitions. To start endpoint service and remote plug-in endpoint in the same time you can start your service, detach process and start remote plug-in endpoint using env variable `PLUGIN_REMOTE_ENDPOINT_EXECUTABLE`. You can do that in the Dockerfile or in the plugin meta.yaml.
